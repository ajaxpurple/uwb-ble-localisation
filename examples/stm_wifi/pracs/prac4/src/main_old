#include "stm32l4xx.h"
#include "ff.h"
#include "s4436572_hal_led.h"
#include "diskio.h"
#include <string.h>
#include "s4436572_hal_printf.h"
#include "s4436572_hal_fatfs.h"

//#include "FreeRTOS.h"

#define printf HAL_Delay(10); debug_printf

static
DWORD pn (DWORD pns){
    static DWORD lfsr;
    UINT n;


    if (pns) {
        lfsr = pns;
        for (n = 0; n < 32; n++) pn(0);
    }
    if (lfsr & 1) {
        lfsr >>= 1;
        lfsr ^= 0x80200003;
    } else {
        lfsr >>= 1;
    }
    return lfsr;
}


void SysTick_Handler(void){
  HAL_IncTick();
}

int test_diskio (
    BYTE pdrv,      /* Physical drive number to be checked (all data on the drive will be lost) */
    UINT ncyc,      /* Number of test cycles */
    DWORD* buff,    /* Pointer to the working buffer */
    UINT sz_buff    /* Size of the working buffer in unit of byte */
)
{
    UINT n, cc, ns;
    DWORD sz_drv, lba, sz_eblk, pns = 1;
    WORD sz_sect;
    BYTE *pbuff = (BYTE*)buff;
    DSTATUS ds;
    DRESULT dr;


    printf("test_diskio(%u, %u, 0x%08X, 0x%08X)\r\n", pdrv, ncyc, (UINT)buff, sz_buff);

    if (sz_buff < _MAX_SS + 4) {
        printf("Insufficient work area to test.\r\n");
        return 1;
    }

    for (cc = 1; cc <= ncyc; cc++) {
        printf("**** Test cycle %u of %u start ****\r\n", cc, ncyc);

        /* Initialization */
        printf(" disk_initalize(%u)", pdrv);
        ds = disk_initialize(pdrv);
        if (ds & STA_NOINIT) {
            printf(" - failed.\r\n");
            return 2;
        } else {
            printf(" - ok.\r\n");
        }

        /* Get drive size */
        printf("**** Get drive size ****\r\n");
        printf(" disk_ioctl(%u, GET_SECTOR_COUNT, 0x%08X)", pdrv, (UINT)&sz_drv);
        sz_drv = 0;
        dr = disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_drv);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 3;
        }
        if (sz_drv < 128) {
            printf("Failed: Insufficient drive size to test.\r\n");
            return 4;
        }
        printf(" Number of sectors on the drive %u is %lu.\r\n", pdrv, sz_drv);

#if _MAX_SS != _MIN_SS
        /* Get sector size */
        printf("**** Get sector size ****\r\n");
        printf(" disk_ioctl(%u, GET_SECTOR_SIZE, 0x%X)", pdrv, (UINT)&sz_sect);
        sz_sect = 0;
        dr = disk_ioctl(pdrv, GET_SECTOR_SIZE, &sz_sect);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 5;
        }
        printf(" Size of sector is %u bytes.\r\n", sz_sect);
#else
        sz_sect = _MAX_SS;
#endif

        /* Get erase block size */
        printf("**** Get block size ****\r\n");
        printf(" disk_ioctl(%u, GET_BLOCK_SIZE, 0x%X)", pdrv, (UINT)&sz_eblk);
        sz_eblk = 0;
        dr = disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_eblk);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
        }
        if (dr == RES_OK || sz_eblk >= 2) {
            printf(" Size of the erase block is %lu sectors.\r\n", sz_eblk);
        } else {
            printf(" Size of the erase block is unknown.\r\n");
        }

        /* Single sector write test */
        printf("**** Single sector write test 1 ****\r\n");
        lba = 1;
        for (n = 0, pn(pns); n < sz_sect; n++) pbuff[n] = (BYTE)pn(0);
        printf(" disk_write(%u, 0x%X, %lu, 1)", pdrv, (UINT)pbuff, lba);
        dr = disk_write(pdrv, pbuff, lba, 1);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 6;
        }
        printf(" disk_ioctl(%u, CTRL_SYNC, NULL)", pdrv);
        dr = disk_ioctl(pdrv, CTRL_SYNC, 0);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 7;
        }
        memset(pbuff, 0, sz_sect);
        printf(" disk_read(%u, 0x%X, %lu, 1)", pdrv, (UINT)pbuff, lba);
        dr = disk_read(pdrv, pbuff, lba, 1);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 8;
        }
        for (n = 0, pn(pns); n < sz_sect && pbuff[n] == (BYTE)pn(0); n++) ;
        if (n == sz_sect) {
            printf(" Data matched.\r\n");
        } else {
            printf("Failed: Read data differs from the data written.\r\n");
            return 10;
        }
        pns++;

        /* Multiple sector write test */
        printf("**** Multiple sector write test ****\r\n");
        lba = 2; ns = sz_buff / sz_sect;
        if (ns > 4) ns = 4;
        for (n = 0, pn(pns); n < (UINT)(sz_sect * ns); n++) pbuff[n] = (BYTE)pn(0);
        printf(" disk_write(%u, 0x%X, %lu, %u)", pdrv, (UINT)pbuff, lba, ns);
        dr = disk_write(pdrv, pbuff, lba, ns);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 11;
        }
        printf(" disk_ioctl(%u, CTRL_SYNC, NULL)", pdrv);
        dr = disk_ioctl(pdrv, CTRL_SYNC, 0);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 12;
        }
        memset(pbuff, 0, sz_sect * ns);
        printf(" disk_read(%u, 0x%X, %lu, %u)", pdrv, (UINT)pbuff, lba, ns);
        dr = disk_read(pdrv, pbuff, lba, ns);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 13;
        }
        for (n = 0, pn(pns); n < (UINT)(sz_sect * ns) && pbuff[n] == (BYTE)pn(0); n++) ;
        if (n == (UINT)(sz_sect * ns)) {
            printf(" Data matched.\r\n");
        } else {
            printf("Failed: Read data differs from the data written.\r\n");
            return 14;
        }
        pns++;

        /* Single sector write test (misaligned memory address) */
        printf("**** Single sector write test (misaligned address) ****\r\n");
        lba = 6;
        for (n = 0, pn(pns); n < sz_sect; n++) pbuff[n+3] = (BYTE)pn(0);
        printf(" disk_write(%u, 0x%X, %lu, 1)", pdrv, (UINT)(pbuff+3), lba);
        dr = disk_write(pdrv, pbuff+3, lba, 1);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 15;
        }
        printf(" disk_ioctl(%u, CTRL_SYNC, NULL)", pdrv);
        dr = disk_ioctl(pdrv, CTRL_SYNC, 0);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 16;
        }
        memset(pbuff+5, 0, sz_sect);
        printf(" disk_read(%u, 0x%X, %lu, 1)", pdrv, (UINT)(pbuff+5), lba);
        dr = disk_read(pdrv, pbuff+5, lba, 1);
        if (dr == RES_OK) {
            printf(" - ok.\r\n");
        } else {
            printf(" - failed.\r\n");
            return 17;
        }
        for (n = 0, pn(pns); n < sz_sect && pbuff[n+5] == (BYTE)pn(0); n++) ;
        if (n == sz_sect) {
            printf(" Data matched.\r\n");
        } else {
            printf("Failed: Read data differs from the data written.\r\n");
            return 18;
        }
        pns++;

        printf("**** Test cycle %u of %u completed ****\r\n\r\n", cc, ncyc);
    }

    return 0;
}

void fatfs_test(){
    FIL f;
    UINT w;
    BYTE str[20];
    BYTE data[10000];
    BYTE work[4096];
    //f_mkfs("", FM_FAT, _MAX_SS, work, sizeof work);
    //s4436572_hal_fatfs_init();
    uint32_t time1 = HAL_GetTick();
    s4436572_hal_fatfs_create_file("a.txt");
    if (s4436572_hal_fatfs_open_file("a.txt", &f, FA_WRITE | FA_OPEN_APPEND) == FR_OK) {
        for(uint8_t i=65; i<75; i++){
            memset(data, i, sizeof(data));
            w = s4436572_hal_fatfs_write_file(&f, data, sizeof(data));
            printf("open & write %d\n\r", w);
        }
    } else {
        printf("open error\n\r");
    }
    s4436572_hal_fatfs_close_file(&f);
    
    uint32_t time2 = HAL_GetTick();

    printf("Data write speed: %d bytes/s\r\n", 1000*sizeof(data)*10/(time2 - time1));

    if (s4436572_hal_fatfs_open_file("a.txt", &f, FA_READ) == FR_OK) {
        for(uint8_t i=65; i<75; i++){
            memset(data, i, sizeof(data));
            w = s4436572_hal_fatfs_read_file(&f, data, sizeof(data));
            printf("open & read %d\n\r", w);
        }
    } else {
        printf("open error\n\r");
    }
    s4436572_hal_fatfs_close_file(&f);
    
    uint32_t time3 = HAL_GetTick();
    printf("Data read speed: %d bytes/s\r\n", 1000*sizeof(data)*10/(time3 - time2));

    if (s4436572_hal_fatfs_open_file("a.txt", &f, FA_CREATE_ALWAYS|FA_READ|FA_WRITE) == FR_OK) {
        w = s4436572_hal_fatfs_write_file(&f, (BYTE*) "abcdef", 7);
        printf("open & write %d\n\r", w);
    } else {
        printf("open error\n\r");
    }
    s4436572_hal_fatfs_close_file(&f);
    if (s4436572_hal_fatfs_open_file("a.txt", &f, FA_READ) == FR_OK) {
        w = s4436572_hal_fatfs_read_file(&f, str, 7);
        printf("Read %s %d\n\r", str, w);
    }
    s4436572_hal_fatfs_close_file(&f);
    
    FolderItems result;
    s4436572_hal_fatfs_list_folder(&result);
    for(uint8_t i=0; i<result.count; i++){
        HAL_Delay(10);
        debug_printf("Name: %s, Size: %d, Time: %d, Type: %d\r\n", result.items[i].name,result.items[i].size, result.items[i].time, result.items[i].type);
    }
}


int main(){
    HAL_Init();
    s4436572_hal_led_init();
    s4436572_hal_printf_init();
    FRESULT sta;
    sta = s4436572_hal_fatfs_init();
    
    debug_printf("Hello %d\r\n", sta);

    int rc;
    DWORD buff[0x401];  /* 2048 byte working buffer */
    /* Check function/compatibility of the physical drive #0 */
    rc = test_diskio(0, 3, buff, sizeof buff);
    HAL_Delay(100);
    if (rc) {
        printf("Sorry the function test failed. (rc=%d)\r\n", rc);
    } else {
        printf("Congratulations! The disk driver works well.\r\n");
    }

   fatfs_test();

    while(1){
        if(rc){
            s4436572_hal_led_toggle(LED_ERR);
        }else{
            s4436572_hal_led_toggle(LED_GREEN1);
        }
        HAL_Delay(100);
    }
}